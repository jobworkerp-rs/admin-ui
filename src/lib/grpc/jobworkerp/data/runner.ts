// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.1
// source: jobworkerp/data/runner.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { RunnerType } from "./common";

export const protobufPackage = "jobworkerp.data";

/**
 * # Output Type
 * Defines the streaming capability of the runner
 */
export enum StreamingOutputType {
  /** NON_STREAMING - Runner only supports non-streaming output */
  NON_STREAMING = 0,
  /** STREAMING - Runner only supports streaming output */
  STREAMING = 1,
  /** BOTH - Runner supports both streaming and non-streaming outputs */
  BOTH = 2,
  UNRECOGNIZED = -1,
}

/**
 * # Runner Sort Field
 * Defines the fields available for sorting runners in queries
 */
export enum RunnerSortField {
  RUNNER_SORT_FIELD_UNSPECIFIED = 0,
  RUNNER_SORT_FIELD_ID = 1,
  RUNNER_SORT_FIELD_NAME = 2,
  RUNNER_SORT_FIELD_RUNNER_TYPE = 3,
  RUNNER_SORT_FIELD_CREATED_AT = 4,
  UNRECOGNIZED = -1,
}

export interface RunnerData {
  /**
   * # Runner Name
   * Unique key and proto message prefix (e.g. name: "command",
   * runner_settings_proto: "CommandRunnerSettings", job_args_proto:
   * "CommandArg")
   */
  name: string;
  /**
   * # Runner Description
   * Description of runner implementation
   */
  description: string;
  /**
   * # Runner Type
   * Defines the category of runner implementation
   */
  runnerType: RunnerType;
  /**
   * # Runner Settings Definition
   * Proto file definition for runner configuration
   */
  runnerSettingsProto: string;
  /**
   * # definition
   * runner definition
   * mcp: mcp_server toml
   * plugin: plugin filepath
   */
  definition: string;
  /**
   * # Method Proto Map (REQUIRED)
   * All runners must provide method-level schema definitions
   * - Single-method runners: use default method name "run"
   * - Multi-method runners: use method-specific names (e.g., "fetch_html", "exec")
   * Maps method name to its input/output protobuf schema definitions
   */
  methodProtoMap: MethodProtoMap | undefined;
}

/**
 * # Method Proto Map
 * Mapping of method names to their Protobuf schema definitions
 */
export interface MethodProtoMap {
  /**
   * # Schemas Map
   * Key: using name (e.g., "fetch_html", "fetch")
   * Value: MethodSchema containing input and optional output schemas
   *
   * When schemas has only one entry, using can be omitted in job execution
   * (auto-selected to the single available method)
   */
  schemas: { [key: string]: MethodSchema };
}

export interface MethodProtoMap_SchemasEntry {
  key: string;
  value: MethodSchema | undefined;
}

/**
 * # Method Schema
 * Input and output Protobuf schema definitions for a single method
 */
export interface MethodSchema {
  /**
   * # Input Arguments Schema
   * Protobuf schema definition for method arguments
   * - Message name follows convention: {ServerName}{ToolName}Args
   * - Example for fetch server's fetch_html tool:
   *   "syntax = \"proto3\";\nmessage FetchFetchHtmlArgs { string url = 1; optional int32 timeout_ms = 2; }"
   */
  argsProto: string;
  /**
   * # Output Result Schema (REQUIRED - proto3 constraint)
   * Protobuf schema definition for method result
   *
   * - **REQUIRED**: This field MUST always be set by application layer
   * - **Proto3 limitation**: Cannot use `required` keyword (proto3 spec)
   * - **Empty string ALLOWED**: For unstructured/binary output
   *
   * Details: See docs/runner-proto-unification-spec.md Section 7.1
   */
  resultProto: string;
  /**
   * # Method Description (Optional)
   * Human-readable description of what this method does
   * - Used by LLM for tool selection
   * - Example: "Fetches HTML content from a URL"
   */
  description?:
    | string
    | undefined;
  /**
   * # Output Type Configuration
   * Specifies the streaming capability of this specific method
   * Allows different methods within the same runner to have different streaming support
   * - NON_STREAMING: Method only supports non-streaming output
   * - STREAMING: Method only supports streaming output
   * - BOTH: Method supports both streaming and non-streaming outputs
   */
  outputType: StreamingOutputType;
}

/**
 * # Method JSON Schema Map
 * Mapping of method names to their JSON Schema definitions
 * This is generated from MethodProtoMap and cached in RunnerWithSchema
 * to avoid repeated Protobuf â†’ JSON Schema conversions
 */
export interface MethodJsonSchemaMap {
  /**
   * # Schemas Map
   * Key: method name (e.g., "run", "fetch_html", "get_current_time")
   * Value: MethodJsonSchema containing input/output JSON schemas
   */
  schemas: { [key: string]: MethodJsonSchema };
}

export interface MethodJsonSchemaMap_SchemasEntry {
  key: string;
  value: MethodJsonSchema | undefined;
}

/**
 * # Method JSON Schema
 * JSON Schema definition for a single method
 * Replaces the deprecated arguments_schema/output_schema/tools fields in RunnerWithSchema
 *
 * NOTE: description is NOT cached here - retrieve from MethodSchema.description instead
 * Reason: description is not converted (just copied), so caching it is redundant
 */
export interface MethodJsonSchema {
  /**
   * # Arguments JSON Schema (REQUIRED)
   * JSON Schema for method arguments
   * - Generated from MethodSchema.args_proto
   * - Example: {"type": "object", "properties": {"url": {"type": "string"}}}
   */
  argsSchema: string;
  /**
   * # Result JSON Schema (Optional)
   * JSON Schema for method result
   * - Generated from MethodSchema.result_proto
   * - None for unstructured output (empty result_proto)
   */
  resultSchema?: string | undefined;
}

export interface RunnerId {
  value: string;
}

export interface Runner {
  id: RunnerId | undefined;
  data: RunnerData | undefined;
}

function createBaseRunnerData(): RunnerData {
  return {
    name: "",
    description: "",
    runnerType: 0,
    runnerSettingsProto: "",
    definition: "",
    methodProtoMap: undefined,
  };
}

export const RunnerData: MessageFns<RunnerData> = {
  encode(message: RunnerData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.runnerType !== 0) {
      writer.uint32(24).int32(message.runnerType);
    }
    if (message.runnerSettingsProto !== "") {
      writer.uint32(34).string(message.runnerSettingsProto);
    }
    if (message.definition !== "") {
      writer.uint32(66).string(message.definition);
    }
    if (message.methodProtoMap !== undefined) {
      MethodProtoMap.encode(message.methodProtoMap, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.runnerType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.runnerSettingsProto = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.methodProtoMap = MethodProtoMap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RunnerData>): RunnerData {
    return RunnerData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunnerData>): RunnerData {
    const message = createBaseRunnerData();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.runnerType = object.runnerType ?? 0;
    message.runnerSettingsProto = object.runnerSettingsProto ?? "";
    message.definition = object.definition ?? "";
    message.methodProtoMap = (object.methodProtoMap !== undefined && object.methodProtoMap !== null)
      ? MethodProtoMap.fromPartial(object.methodProtoMap)
      : undefined;
    return message;
  },
};

function createBaseMethodProtoMap(): MethodProtoMap {
  return { schemas: {} };
}

export const MethodProtoMap: MessageFns<MethodProtoMap> = {
  encode(message: MethodProtoMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.schemas).forEach(([key, value]) => {
      MethodProtoMap_SchemasEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodProtoMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodProtoMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MethodProtoMap_SchemasEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.schemas[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MethodProtoMap>): MethodProtoMap {
    return MethodProtoMap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MethodProtoMap>): MethodProtoMap {
    const message = createBaseMethodProtoMap();
    message.schemas = Object.entries(object.schemas ?? {}).reduce<{ [key: string]: MethodSchema }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = MethodSchema.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMethodProtoMap_SchemasEntry(): MethodProtoMap_SchemasEntry {
  return { key: "", value: undefined };
}

export const MethodProtoMap_SchemasEntry: MessageFns<MethodProtoMap_SchemasEntry> = {
  encode(message: MethodProtoMap_SchemasEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MethodSchema.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodProtoMap_SchemasEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodProtoMap_SchemasEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MethodSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MethodProtoMap_SchemasEntry>): MethodProtoMap_SchemasEntry {
    return MethodProtoMap_SchemasEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MethodProtoMap_SchemasEntry>): MethodProtoMap_SchemasEntry {
    const message = createBaseMethodProtoMap_SchemasEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MethodSchema.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMethodSchema(): MethodSchema {
  return { argsProto: "", resultProto: "", description: undefined, outputType: 0 };
}

export const MethodSchema: MessageFns<MethodSchema> = {
  encode(message: MethodSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.argsProto !== "") {
      writer.uint32(10).string(message.argsProto);
    }
    if (message.resultProto !== "") {
      writer.uint32(18).string(message.resultProto);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.outputType !== 0) {
      writer.uint32(32).int32(message.outputType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.argsProto = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resultProto = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.outputType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MethodSchema>): MethodSchema {
    return MethodSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MethodSchema>): MethodSchema {
    const message = createBaseMethodSchema();
    message.argsProto = object.argsProto ?? "";
    message.resultProto = object.resultProto ?? "";
    message.description = object.description ?? undefined;
    message.outputType = object.outputType ?? 0;
    return message;
  },
};

function createBaseMethodJsonSchemaMap(): MethodJsonSchemaMap {
  return { schemas: {} };
}

export const MethodJsonSchemaMap: MessageFns<MethodJsonSchemaMap> = {
  encode(message: MethodJsonSchemaMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.schemas).forEach(([key, value]) => {
      MethodJsonSchemaMap_SchemasEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodJsonSchemaMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodJsonSchemaMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MethodJsonSchemaMap_SchemasEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.schemas[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MethodJsonSchemaMap>): MethodJsonSchemaMap {
    return MethodJsonSchemaMap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MethodJsonSchemaMap>): MethodJsonSchemaMap {
    const message = createBaseMethodJsonSchemaMap();
    message.schemas = Object.entries(object.schemas ?? {}).reduce<{ [key: string]: MethodJsonSchema }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = MethodJsonSchema.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMethodJsonSchemaMap_SchemasEntry(): MethodJsonSchemaMap_SchemasEntry {
  return { key: "", value: undefined };
}

export const MethodJsonSchemaMap_SchemasEntry: MessageFns<MethodJsonSchemaMap_SchemasEntry> = {
  encode(message: MethodJsonSchemaMap_SchemasEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MethodJsonSchema.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodJsonSchemaMap_SchemasEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodJsonSchemaMap_SchemasEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MethodJsonSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MethodJsonSchemaMap_SchemasEntry>): MethodJsonSchemaMap_SchemasEntry {
    return MethodJsonSchemaMap_SchemasEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MethodJsonSchemaMap_SchemasEntry>): MethodJsonSchemaMap_SchemasEntry {
    const message = createBaseMethodJsonSchemaMap_SchemasEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MethodJsonSchema.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMethodJsonSchema(): MethodJsonSchema {
  return { argsSchema: "", resultSchema: undefined };
}

export const MethodJsonSchema: MessageFns<MethodJsonSchema> = {
  encode(message: MethodJsonSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.argsSchema !== "") {
      writer.uint32(10).string(message.argsSchema);
    }
    if (message.resultSchema !== undefined) {
      writer.uint32(18).string(message.resultSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodJsonSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodJsonSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.argsSchema = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resultSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MethodJsonSchema>): MethodJsonSchema {
    return MethodJsonSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MethodJsonSchema>): MethodJsonSchema {
    const message = createBaseMethodJsonSchema();
    message.argsSchema = object.argsSchema ?? "";
    message.resultSchema = object.resultSchema ?? undefined;
    return message;
  },
};

function createBaseRunnerId(): RunnerId {
  return { value: "0" };
}

export const RunnerId: MessageFns<RunnerId> = {
  encode(message: RunnerId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "0") {
      writer.uint32(8).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnerId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RunnerId>): RunnerId {
    return RunnerId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunnerId>): RunnerId {
    const message = createBaseRunnerId();
    message.value = object.value ?? "0";
    return message;
  },
};

function createBaseRunner(): Runner {
  return { id: undefined, data: undefined };
}

export const Runner: MessageFns<Runner> = {
  encode(message: Runner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      RunnerId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      RunnerData.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = RunnerId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = RunnerData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Runner>): Runner {
    return Runner.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Runner>): Runner {
    const message = createBaseRunner();
    message.id = (object.id !== undefined && object.id !== null) ? RunnerId.fromPartial(object.id) : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? RunnerData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
