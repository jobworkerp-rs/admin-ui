// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.1
// source: jobworkerp/data/workflow_event.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "jobworkerp.data";

/**
 * # Job Started Event
 * Event emitted when a job (RunTask) begins execution
 * Used for both streaming and non-streaming jobs
 */
export interface JobStartedEvent {
  /**
   * # Job ID
   * Unique identifier of the enqueued job
   */
  jobId: string;
  /**
   * # Runner Name
   * Name of the runner executing the job (e.g., "LLM_CHAT", "COMMAND")
   */
  runnerName: string;
  /**
   * # Worker Name
   * Name of the worker processing the job
   */
  workerName: string;
  /**
   * # Position
   * Position in the workflow (JSON Pointer format, e.g., "/tasks/0/do/1")
   */
  position: string;
}

/**
 * # Job Completed Event
 * Event emitted when a job (RunTask) completes execution
 * Used for both streaming and non-streaming jobs
 */
export interface JobCompletedEvent {
  /**
   * # Job ID
   * Unique identifier of the completed job
   */
  jobId: string;
  /**
   * # Job Result ID
   * ID of the stored job result (available when store_success=true)
   */
  jobResultId?:
    | string
    | undefined;
  /**
   * # Position
   * Position in the workflow (JSON Pointer format)
   */
  position: string;
  /**
   * # Output
   * Serialized TaskContext output (JSON bytes)
   */
  output: Uint8Array;
}

/**
 * # Task Started Event
 * Event emitted when a generic task (ForTask, SwitchTask, DoTask, etc.) begins
 * These tasks do not execute jobs directly but orchestrate other tasks
 */
export interface TaskStartedEvent {
  /**
   * # Task Type
   * Type of the task (e.g., "forTask", "switchTask", "doTask", "tryTask")
   */
  taskType: string;
  /**
   * # Task Name
   * Name of the task as defined in the workflow
   */
  taskName: string;
  /**
   * # Position
   * Position in the workflow (JSON Pointer format)
   */
  position: string;
}

/**
 * # Task Completed Event
 * Event emitted when a generic task completes
 */
export interface TaskCompletedEvent {
  /**
   * # Task Type
   * Type of the task (e.g., "forTask", "switchTask", "doTask", "tryTask")
   */
  taskType: string;
  /**
   * # Task Name
   * Name of the task as defined in the workflow
   */
  taskName: string;
  /**
   * # Position
   * Position in the workflow (JSON Pointer format)
   */
  position: string;
  /**
   * # Output
   * Serialized TaskContext output (JSON bytes)
   */
  output: Uint8Array;
}

/**
 * # Workflow Cancelled Event
 * Event emitted when a workflow is cancelled (reserved for future use)
 */
export interface WorkflowCancelledEvent {
  /**
   * # Reason
   * Description of why the workflow was cancelled
   */
  reason: string;
  /**
   * # Position
   * Position in the workflow where cancellation occurred
   */
  position: string;
}

/**
 * # Streaming Data Event
 * Event emitted for each chunk of streaming data (e.g., LLM token)
 * Used for real-time streaming to clients (e.g., AG-UI TEXT_MESSAGE_CONTENT)
 */
export interface StreamingDataEvent {
  /**
   * # Job ID
   * Unique identifier of the streaming job
   */
  jobId: string;
  /**
   * # Data
   * Raw streaming data chunk (typically UTF-8 encoded text)
   */
  data: Uint8Array;
}

/**
 * # Workflow Event
 * Union type representing all possible events during workflow execution
 * Used for streaming workflow progress to clients (e.g., AG-UI)
 */
export interface WorkflowEvent {
  /**
   * # Streaming Job Started
   * Emitted when a streaming job (e.g., LLM_CHAT) begins
   * Client can subscribe to job results via:
   * - listen_result(streaming=true)
   * - gRPC ListenStream
   */
  streamingJobStarted?:
    | JobStartedEvent
    | undefined;
  /**
   * # Streaming Job Completed
   * Emitted when a streaming job finishes
   * Result can be retrieved via job_result_id if stored
   */
  streamingJobCompleted?:
    | JobCompletedEvent
    | undefined;
  /**
   * # Non-Streaming Job Started
   * Emitted when a regular job begins
   * Client can subscribe to job results via:
   * - listen_result(streaming=false)
   * - gRPC Listen
   */
  jobStarted?:
    | JobStartedEvent
    | undefined;
  /**
   * # Non-Streaming Job Completed
   * Emitted when a regular job finishes
   * Result can be retrieved via job_result_id if stored
   */
  jobCompleted?:
    | JobCompletedEvent
    | undefined;
  /**
   * # Generic Task Started
   * Emitted when ForTask, SwitchTask, DoTask, etc. begins
   */
  taskStarted?:
    | TaskStartedEvent
    | undefined;
  /**
   * # Generic Task Completed
   * Emitted when ForTask, SwitchTask, DoTask, etc. finishes
   */
  taskCompleted?:
    | TaskCompletedEvent
    | undefined;
  /**
   * # Streaming Data
   * Emitted for each chunk of streaming data (e.g., LLM token)
   * Used for real-time streaming to AG-UI clients
   */
  streamingData?:
    | StreamingDataEvent
    | undefined;
  /**
   * # Workflow Cancelled (Reserved)
   * Emitted when workflow is cancelled
   */
  workflowCancelled?: WorkflowCancelledEvent | undefined;
}

function createBaseJobStartedEvent(): JobStartedEvent {
  return { jobId: "0", runnerName: "", workerName: "", position: "" };
}

export const JobStartedEvent: MessageFns<JobStartedEvent> = {
  encode(message: JobStartedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "0") {
      writer.uint32(8).int64(message.jobId);
    }
    if (message.runnerName !== "") {
      writer.uint32(18).string(message.runnerName);
    }
    if (message.workerName !== "") {
      writer.uint32(26).string(message.workerName);
    }
    if (message.position !== "") {
      writer.uint32(34).string(message.position);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobStartedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobStartedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.jobId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runnerName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workerName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.position = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<JobStartedEvent>): JobStartedEvent {
    return JobStartedEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobStartedEvent>): JobStartedEvent {
    const message = createBaseJobStartedEvent();
    message.jobId = object.jobId ?? "0";
    message.runnerName = object.runnerName ?? "";
    message.workerName = object.workerName ?? "";
    message.position = object.position ?? "";
    return message;
  },
};

function createBaseJobCompletedEvent(): JobCompletedEvent {
  return { jobId: "0", jobResultId: undefined, position: "", output: new Uint8Array(0) };
}

export const JobCompletedEvent: MessageFns<JobCompletedEvent> = {
  encode(message: JobCompletedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "0") {
      writer.uint32(8).int64(message.jobId);
    }
    if (message.jobResultId !== undefined) {
      writer.uint32(16).int64(message.jobResultId);
    }
    if (message.position !== "") {
      writer.uint32(26).string(message.position);
    }
    if (message.output.length !== 0) {
      writer.uint32(34).bytes(message.output);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobCompletedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobCompletedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.jobId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.jobResultId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.output = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<JobCompletedEvent>): JobCompletedEvent {
    return JobCompletedEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobCompletedEvent>): JobCompletedEvent {
    const message = createBaseJobCompletedEvent();
    message.jobId = object.jobId ?? "0";
    message.jobResultId = object.jobResultId ?? undefined;
    message.position = object.position ?? "";
    message.output = object.output ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTaskStartedEvent(): TaskStartedEvent {
  return { taskType: "", taskName: "", position: "" };
}

export const TaskStartedEvent: MessageFns<TaskStartedEvent> = {
  encode(message: TaskStartedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskType !== "") {
      writer.uint32(10).string(message.taskType);
    }
    if (message.taskName !== "") {
      writer.uint32(18).string(message.taskName);
    }
    if (message.position !== "") {
      writer.uint32(26).string(message.position);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskStartedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskStartedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskStartedEvent>): TaskStartedEvent {
    return TaskStartedEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskStartedEvent>): TaskStartedEvent {
    const message = createBaseTaskStartedEvent();
    message.taskType = object.taskType ?? "";
    message.taskName = object.taskName ?? "";
    message.position = object.position ?? "";
    return message;
  },
};

function createBaseTaskCompletedEvent(): TaskCompletedEvent {
  return { taskType: "", taskName: "", position: "", output: new Uint8Array(0) };
}

export const TaskCompletedEvent: MessageFns<TaskCompletedEvent> = {
  encode(message: TaskCompletedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskType !== "") {
      writer.uint32(10).string(message.taskType);
    }
    if (message.taskName !== "") {
      writer.uint32(18).string(message.taskName);
    }
    if (message.position !== "") {
      writer.uint32(26).string(message.position);
    }
    if (message.output.length !== 0) {
      writer.uint32(34).bytes(message.output);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskCompletedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskCompletedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.output = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TaskCompletedEvent>): TaskCompletedEvent {
    return TaskCompletedEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskCompletedEvent>): TaskCompletedEvent {
    const message = createBaseTaskCompletedEvent();
    message.taskType = object.taskType ?? "";
    message.taskName = object.taskName ?? "";
    message.position = object.position ?? "";
    message.output = object.output ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWorkflowCancelledEvent(): WorkflowCancelledEvent {
  return { reason: "", position: "" };
}

export const WorkflowCancelledEvent: MessageFns<WorkflowCancelledEvent> = {
  encode(message: WorkflowCancelledEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    if (message.position !== "") {
      writer.uint32(18).string(message.position);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowCancelledEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowCancelledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkflowCancelledEvent>): WorkflowCancelledEvent {
    return WorkflowCancelledEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowCancelledEvent>): WorkflowCancelledEvent {
    const message = createBaseWorkflowCancelledEvent();
    message.reason = object.reason ?? "";
    message.position = object.position ?? "";
    return message;
  },
};

function createBaseStreamingDataEvent(): StreamingDataEvent {
  return { jobId: "0", data: new Uint8Array(0) };
}

export const StreamingDataEvent: MessageFns<StreamingDataEvent> = {
  encode(message: StreamingDataEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "0") {
      writer.uint32(8).int64(message.jobId);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingDataEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingDataEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.jobId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StreamingDataEvent>): StreamingDataEvent {
    return StreamingDataEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingDataEvent>): StreamingDataEvent {
    const message = createBaseStreamingDataEvent();
    message.jobId = object.jobId ?? "0";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWorkflowEvent(): WorkflowEvent {
  return {
    streamingJobStarted: undefined,
    streamingJobCompleted: undefined,
    jobStarted: undefined,
    jobCompleted: undefined,
    taskStarted: undefined,
    taskCompleted: undefined,
    streamingData: undefined,
    workflowCancelled: undefined,
  };
}

export const WorkflowEvent: MessageFns<WorkflowEvent> = {
  encode(message: WorkflowEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamingJobStarted !== undefined) {
      JobStartedEvent.encode(message.streamingJobStarted, writer.uint32(10).fork()).join();
    }
    if (message.streamingJobCompleted !== undefined) {
      JobCompletedEvent.encode(message.streamingJobCompleted, writer.uint32(18).fork()).join();
    }
    if (message.jobStarted !== undefined) {
      JobStartedEvent.encode(message.jobStarted, writer.uint32(26).fork()).join();
    }
    if (message.jobCompleted !== undefined) {
      JobCompletedEvent.encode(message.jobCompleted, writer.uint32(34).fork()).join();
    }
    if (message.taskStarted !== undefined) {
      TaskStartedEvent.encode(message.taskStarted, writer.uint32(42).fork()).join();
    }
    if (message.taskCompleted !== undefined) {
      TaskCompletedEvent.encode(message.taskCompleted, writer.uint32(50).fork()).join();
    }
    if (message.streamingData !== undefined) {
      StreamingDataEvent.encode(message.streamingData, writer.uint32(58).fork()).join();
    }
    if (message.workflowCancelled !== undefined) {
      WorkflowCancelledEvent.encode(message.workflowCancelled, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.streamingJobStarted = JobStartedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.streamingJobCompleted = JobCompletedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.jobStarted = JobStartedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jobCompleted = JobCompletedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.taskStarted = TaskStartedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.taskCompleted = TaskCompletedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.streamingData = StreamingDataEvent.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.workflowCancelled = WorkflowCancelledEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkflowEvent>): WorkflowEvent {
    return WorkflowEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkflowEvent>): WorkflowEvent {
    const message = createBaseWorkflowEvent();
    message.streamingJobStarted = (object.streamingJobStarted !== undefined && object.streamingJobStarted !== null)
      ? JobStartedEvent.fromPartial(object.streamingJobStarted)
      : undefined;
    message.streamingJobCompleted =
      (object.streamingJobCompleted !== undefined && object.streamingJobCompleted !== null)
        ? JobCompletedEvent.fromPartial(object.streamingJobCompleted)
        : undefined;
    message.jobStarted = (object.jobStarted !== undefined && object.jobStarted !== null)
      ? JobStartedEvent.fromPartial(object.jobStarted)
      : undefined;
    message.jobCompleted = (object.jobCompleted !== undefined && object.jobCompleted !== null)
      ? JobCompletedEvent.fromPartial(object.jobCompleted)
      : undefined;
    message.taskStarted = (object.taskStarted !== undefined && object.taskStarted !== null)
      ? TaskStartedEvent.fromPartial(object.taskStarted)
      : undefined;
    message.taskCompleted = (object.taskCompleted !== undefined && object.taskCompleted !== null)
      ? TaskCompletedEvent.fromPartial(object.taskCompleted)
      : undefined;
    message.streamingData = (object.streamingData !== undefined && object.streamingData !== null)
      ? StreamingDataEvent.fromPartial(object.streamingData)
      : undefined;
    message.workflowCancelled = (object.workflowCancelled !== undefined && object.workflowCancelled !== null)
      ? WorkflowCancelledEvent.fromPartial(object.workflowCancelled)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
