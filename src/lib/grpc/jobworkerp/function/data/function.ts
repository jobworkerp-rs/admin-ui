// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.1
// source: jobworkerp/function/data/function.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { QueueType, ResponseType, ResultStatus, RetryPolicy, RunnerType } from "../../data/common";
import { RunnerId, StreamingOutputType } from "../../data/runner";
import { WorkerId } from "../../data/worker";

export const protobufPackage = "jobworkerp.function.data";

/**
 * # Function ID
 * Unified identifier for either a Runner or Worker
 * Symmetric design: both runner and worker are at the same level
 */
export interface FunctionId {
  runnerId?: RunnerId | undefined;
  workerId?: WorkerId | undefined;
}

/**
 * # Function Using
 * Function identifier with optional using specification
 * Used in Function layer to specify:
 * - Which function to execute (function_id)
 * - Which implementation to use (using, for MCP/Plugin runners)
 *
 * Examples:
 * 1. Normal runner: FunctionUsing { function_id: RunnerId(1), using: None }
 * 2. MCP runner (all tools): FunctionUsing { function_id: RunnerId(100), using: None }
 * 3. MCP runner (specific tool): FunctionUsing { function_id: RunnerId(100), using: Some("fetch_html") }
 * 4. Worker: FunctionUsing { function_id: WorkerId(200), using: None }
 */
export interface FunctionUsing {
  /**
   * # Function ID
   * Reference to the runner or worker
   */
  functionId:
    | FunctionId
    | undefined;
  /**
   * # Using
   * Optional: specifies a particular tool/method within the runner
   * - For normal runners: ignored (no sub-methods)
   * - For MCP/Plugin runners:
   *   - If specified: Only this specific tool is selected
   *   - If omitted and only 1 tool: auto-selected
   *   - If omitted and multiple tools: entire runner is selected
   * - For workers: ignored (workers don't have sub-methods)
   */
  using?: string | undefined;
}

/**
 * # Function Specs
 * Metadata that describes function capabilities and interface for clients
 * Represents either a runner or worker as a function
 */
export interface FunctionSpecs {
  /** # Runner Type */
  runnerType: RunnerType;
  /**
   * # Runner ID
   * Runner Id for the function
   */
  runnerId:
    | RunnerId
    | undefined;
  /**
   * # Worker ID
   * Worker Id for the function. present if created as a worker
   */
  workerId?:
    | WorkerId
    | undefined;
  /**
   * # Function Name
   * Unique identifier for the function (e.g. "command", "image-processor")
   */
  name: string;
  /**
   * # Function Description
   * Human-readable explanation of what the function does
   */
  description: string;
  /**
   * # Function Settings Definition (REQUIRED)
   * JSON schema for function-level settings (e.g., API keys, base URLs)
   * - For runners without settings: empty string ""
   * - For workers: empty string "" (workers use WorkerOptions instead)
   * - Example: "{\"type\": \"object\", \"properties\": {\"api_key\": {\"type\": \"string\"}}}"
   */
  settingsSchema: string;
  /**
   * # Method Schemas (REQUIRED)
   * Map of method name to method schema
   * - Key: method name (e.g., "run", "fetch_html", "get_current_time")
   * - Value: MethodSchema (input/output schemas, output_type)
   * - Single-method runners: contains 1 entry (key = "run")
   * - MCP/Plugin runners: contains multiple entries (keys = tool names)
   */
  methods: MethodSchemaMap | undefined;
}

/**
 * # Method Schema Map
 * Container for all method schemas in a function
 * Uses map for O(1) access and consistency with RunnerData.method_proto_map
 */
export interface MethodSchemaMap {
  /**
   * # Schemas Map
   * Key: method name (e.g., "run", "fetch_html", "get_current_time")
   * Value: MethodSchema (input/output schemas, streaming capability)
   *
   * Design rationale for map (not repeated):
   * - Consistency: Matches RunnerData.method_proto_map structure
   * - Efficiency: O(1) method lookup by name
   * - Uniqueness: Protobuf map enforces unique keys
   */
  schemas: { [key: string]: MethodSchema };
}

export interface MethodSchemaMap_SchemasEntry {
  key: string;
  value: MethodSchema | undefined;
}

/**
 * # Method Schema
 * JSON Schema definition for a single method/tool
 */
export interface MethodSchema {
  /**
   * # Method Description (Optional)
   * Human-readable explanation of what this method does
   * Used by LLM for tool selection
   */
  description?:
    | string
    | undefined;
  /**
   * # Arguments JSON Schema (REQUIRED)
   * JSON Schema defining the input parameters for this method
   * Example: {"type": "object", "properties": {"url": {"type": "string"}}}
   */
  argumentsSchema: string;
  /**
   * # Result JSON Schema (Optional)
   * JSON Schema defining the output structure for this method
   * None for unstructured/binary output
   */
  resultSchema?:
    | string
    | undefined;
  /**
   * # Output Type (REQUIRED)
   * Streaming capability of this specific method
   * - NON_STREAMING: Method only supports synchronous execution
   * - STREAMING: Method only supports streaming output
   * - BOTH: Method supports both modes
   */
  outputType: StreamingOutputType;
  /**
   * # Tool Annotations (Optional)
   * MCP-specific metadata for tool behavior hints
   * Only populated for MCP server tools
   * NOTE: all properties are **hints** and should not be trusted
   */
  annotations?: ToolAnnotations | undefined;
}

/**
 * # Additional properties describing a Tool to clients.
 *
 * NOTE: all properties in ToolAnnotations are **hints**.
 * They are not guaranteed to provide a faithful description of
 * tool behavior (including descriptive properties like `title`).
 *
 * Clients should never make tool use decisions based on ToolAnnotations
 * received from untrusted servers.
 */
export interface ToolAnnotations {
  /** # A human-readable title for the tool. */
  title?:
    | string
    | undefined;
  /** If true, the tool does not modify its environment. */
  readOnlyHint?:
    | boolean
    | undefined;
  /**
   * # A human-readable description of the tool's purpose.
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   * (This property is meaningful only when `readOnlyHint == false`)
   * Default: true
   */
  destructiveHint?:
    | boolean
    | undefined;
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   * (This property is meaningful only when `readOnlyHint == false`)
   */
  idempotentHint?:
    | boolean
    | undefined;
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   * Default: true
   */
  openWorldHint?: boolean | undefined;
}

/**
 * # Worker options
 * Configuration for worker execution (partial jobworkerp.data.WorkerData)
 */
export interface WorkerOptions {
  /**
   * # Retry Policy
   * Configuration for job retry behavior on failure
   */
  retryPolicy?:
    | RetryPolicy
    | undefined;
  /**
   * # Channel Name
   * Message channel for job (if empty, default channel will be used)
   */
  channel?:
    | string
    | undefined;
  /**
   * # Store Success Flag
   * If true, job results will be stored in database when execution succeeds
   */
  storeSuccess: boolean;
  /**
   * # Store Failure Flag
   * If true, job results will be stored in database when execution fails
   */
  storeFailure: boolean;
  /**
   * # Static Execution Flag
   * If true, keep a fixed number instance of this worker running at a time in
   * memory
   */
  useStatic: boolean;
  /**
   * # Output Broadcast Flag
   * Broadcast job results to all result listeners or not.
   * If false, cannot use JobResultService/{Listen, ListenStream,
   * ListenByWorker}.
   */
  broadcastResults: boolean;
  /**
   * # Queue Type
   * Defines how jobs are queued and persisted
   * Default: NORMAL (in-memory only, fast)
   */
  queueType?:
    | QueueType
    | undefined;
  /**
   * # Response Type
   * Defines how job results should be returned to the client
   * Default: DIRECT (synchronous execution with result)
   */
  responseType?: ResponseType | undefined;
}

/**
 * # Function Call Options
 * Options for function call execution
 */
export interface FunctionCallOptions {
  /** Timeout in milliseconds */
  timeoutMs?:
    | string
    | undefined;
  /** Enable streaming output */
  streaming?:
    | boolean
    | undefined;
  /** Custom metadata for request context */
  metadata: { [key: string]: string };
}

export interface FunctionCallOptions_MetadataEntry {
  key: string;
  value: string;
}

/**
 * # Function Execution Metadata
 * Contains metadata about function execution
 */
export interface FunctionExecutionInfo {
  /** Job ID assigned to this execution */
  jobId: string;
  /** Execution start time (Unix timestamp in milliseconds) */
  startedAt: string;
  /** Execution completion time (Unix timestamp in milliseconds) */
  completedAt?:
    | string
    | undefined;
  /** Total execution time in milliseconds */
  executionTimeMs?:
    | string
    | undefined;
  /** Additional metadata for the execution(trail) */
  metadata: { [key: string]: string };
}

export interface FunctionExecutionInfo_MetadataEntry {
  key: string;
  value: string;
}

/**
 * # Function Result Data
 * Contains the execution result and metadata of a function call
 */
export interface FunctionResult {
  /**
   * # Result Output
   * Function execution output data (JSON string)
   */
  output: string;
  /**
   * # Result Status
   * Execution status of the function (success, failure, etc.)
   */
  status?:
    | ResultStatus
    | undefined;
  /**
   * # Error Message
   * Detailed error message when execution fails
   */
  errorMessage?:
    | string
    | undefined;
  /**
   * # Error Code
   * Error code for programmatic error handling
   */
  errorCode?:
    | string
    | undefined;
  /**
   * # Execution last info
   * Additional information about the execution in last of stream
   */
  lastInfo?: FunctionExecutionInfo | undefined;
}

function createBaseFunctionId(): FunctionId {
  return { runnerId: undefined, workerId: undefined };
}

export const FunctionId: MessageFns<FunctionId> = {
  encode(message: FunctionId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runnerId !== undefined) {
      RunnerId.encode(message.runnerId, writer.uint32(10).fork()).join();
    }
    if (message.workerId !== undefined) {
      WorkerId.encode(message.workerId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runnerId = RunnerId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workerId = WorkerId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FunctionId>): FunctionId {
    return FunctionId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionId>): FunctionId {
    const message = createBaseFunctionId();
    message.runnerId = (object.runnerId !== undefined && object.runnerId !== null)
      ? RunnerId.fromPartial(object.runnerId)
      : undefined;
    message.workerId = (object.workerId !== undefined && object.workerId !== null)
      ? WorkerId.fromPartial(object.workerId)
      : undefined;
    return message;
  },
};

function createBaseFunctionUsing(): FunctionUsing {
  return { functionId: undefined, using: undefined };
}

export const FunctionUsing: MessageFns<FunctionUsing> = {
  encode(message: FunctionUsing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.functionId !== undefined) {
      FunctionId.encode(message.functionId, writer.uint32(10).fork()).join();
    }
    if (message.using !== undefined) {
      writer.uint32(18).string(message.using);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionUsing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionUsing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.functionId = FunctionId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.using = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FunctionUsing>): FunctionUsing {
    return FunctionUsing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionUsing>): FunctionUsing {
    const message = createBaseFunctionUsing();
    message.functionId = (object.functionId !== undefined && object.functionId !== null)
      ? FunctionId.fromPartial(object.functionId)
      : undefined;
    message.using = object.using ?? undefined;
    return message;
  },
};

function createBaseFunctionSpecs(): FunctionSpecs {
  return {
    runnerType: 0,
    runnerId: undefined,
    workerId: undefined,
    name: "",
    description: "",
    settingsSchema: "",
    methods: undefined,
  };
}

export const FunctionSpecs: MessageFns<FunctionSpecs> = {
  encode(message: FunctionSpecs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runnerType !== 0) {
      writer.uint32(8).int32(message.runnerType);
    }
    if (message.runnerId !== undefined) {
      RunnerId.encode(message.runnerId, writer.uint32(18).fork()).join();
    }
    if (message.workerId !== undefined) {
      WorkerId.encode(message.workerId, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.settingsSchema !== "") {
      writer.uint32(50).string(message.settingsSchema);
    }
    if (message.methods !== undefined) {
      MethodSchemaMap.encode(message.methods, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionSpecs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionSpecs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.runnerType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runnerId = RunnerId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workerId = WorkerId.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.settingsSchema = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.methods = MethodSchemaMap.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FunctionSpecs>): FunctionSpecs {
    return FunctionSpecs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionSpecs>): FunctionSpecs {
    const message = createBaseFunctionSpecs();
    message.runnerType = object.runnerType ?? 0;
    message.runnerId = (object.runnerId !== undefined && object.runnerId !== null)
      ? RunnerId.fromPartial(object.runnerId)
      : undefined;
    message.workerId = (object.workerId !== undefined && object.workerId !== null)
      ? WorkerId.fromPartial(object.workerId)
      : undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.settingsSchema = object.settingsSchema ?? "";
    message.methods = (object.methods !== undefined && object.methods !== null)
      ? MethodSchemaMap.fromPartial(object.methods)
      : undefined;
    return message;
  },
};

function createBaseMethodSchemaMap(): MethodSchemaMap {
  return { schemas: {} };
}

export const MethodSchemaMap: MessageFns<MethodSchemaMap> = {
  encode(message: MethodSchemaMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.schemas).forEach(([key, value]) => {
      MethodSchemaMap_SchemasEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodSchemaMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodSchemaMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MethodSchemaMap_SchemasEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.schemas[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MethodSchemaMap>): MethodSchemaMap {
    return MethodSchemaMap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MethodSchemaMap>): MethodSchemaMap {
    const message = createBaseMethodSchemaMap();
    message.schemas = Object.entries(object.schemas ?? {}).reduce<{ [key: string]: MethodSchema }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = MethodSchema.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMethodSchemaMap_SchemasEntry(): MethodSchemaMap_SchemasEntry {
  return { key: "", value: undefined };
}

export const MethodSchemaMap_SchemasEntry: MessageFns<MethodSchemaMap_SchemasEntry> = {
  encode(message: MethodSchemaMap_SchemasEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      MethodSchema.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodSchemaMap_SchemasEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodSchemaMap_SchemasEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = MethodSchema.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MethodSchemaMap_SchemasEntry>): MethodSchemaMap_SchemasEntry {
    return MethodSchemaMap_SchemasEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MethodSchemaMap_SchemasEntry>): MethodSchemaMap_SchemasEntry {
    const message = createBaseMethodSchemaMap_SchemasEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? MethodSchema.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMethodSchema(): MethodSchema {
  return {
    description: undefined,
    argumentsSchema: "",
    resultSchema: undefined,
    outputType: 0,
    annotations: undefined,
  };
}

export const MethodSchema: MessageFns<MethodSchema> = {
  encode(message: MethodSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== undefined) {
      writer.uint32(10).string(message.description);
    }
    if (message.argumentsSchema !== "") {
      writer.uint32(18).string(message.argumentsSchema);
    }
    if (message.resultSchema !== undefined) {
      writer.uint32(26).string(message.resultSchema);
    }
    if (message.outputType !== 0) {
      writer.uint32(32).int32(message.outputType);
    }
    if (message.annotations !== undefined) {
      ToolAnnotations.encode(message.annotations, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MethodSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMethodSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.argumentsSchema = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultSchema = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.outputType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.annotations = ToolAnnotations.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MethodSchema>): MethodSchema {
    return MethodSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MethodSchema>): MethodSchema {
    const message = createBaseMethodSchema();
    message.description = object.description ?? undefined;
    message.argumentsSchema = object.argumentsSchema ?? "";
    message.resultSchema = object.resultSchema ?? undefined;
    message.outputType = object.outputType ?? 0;
    message.annotations = (object.annotations !== undefined && object.annotations !== null)
      ? ToolAnnotations.fromPartial(object.annotations)
      : undefined;
    return message;
  },
};

function createBaseToolAnnotations(): ToolAnnotations {
  return {
    title: undefined,
    readOnlyHint: undefined,
    destructiveHint: undefined,
    idempotentHint: undefined,
    openWorldHint: undefined,
  };
}

export const ToolAnnotations: MessageFns<ToolAnnotations> = {
  encode(message: ToolAnnotations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== undefined) {
      writer.uint32(10).string(message.title);
    }
    if (message.readOnlyHint !== undefined) {
      writer.uint32(16).bool(message.readOnlyHint);
    }
    if (message.destructiveHint !== undefined) {
      writer.uint32(24).bool(message.destructiveHint);
    }
    if (message.idempotentHint !== undefined) {
      writer.uint32(32).bool(message.idempotentHint);
    }
    if (message.openWorldHint !== undefined) {
      writer.uint32(40).bool(message.openWorldHint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolAnnotations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolAnnotations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.readOnlyHint = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.destructiveHint = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.idempotentHint = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.openWorldHint = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ToolAnnotations>): ToolAnnotations {
    return ToolAnnotations.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolAnnotations>): ToolAnnotations {
    const message = createBaseToolAnnotations();
    message.title = object.title ?? undefined;
    message.readOnlyHint = object.readOnlyHint ?? undefined;
    message.destructiveHint = object.destructiveHint ?? undefined;
    message.idempotentHint = object.idempotentHint ?? undefined;
    message.openWorldHint = object.openWorldHint ?? undefined;
    return message;
  },
};

function createBaseWorkerOptions(): WorkerOptions {
  return {
    retryPolicy: undefined,
    channel: undefined,
    storeSuccess: false,
    storeFailure: false,
    useStatic: false,
    broadcastResults: false,
    queueType: undefined,
    responseType: undefined,
  };
}

export const WorkerOptions: MessageFns<WorkerOptions> = {
  encode(message: WorkerOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryPolicy !== undefined) {
      RetryPolicy.encode(message.retryPolicy, writer.uint32(10).fork()).join();
    }
    if (message.channel !== undefined) {
      writer.uint32(18).string(message.channel);
    }
    if (message.storeSuccess !== false) {
      writer.uint32(32).bool(message.storeSuccess);
    }
    if (message.storeFailure !== false) {
      writer.uint32(40).bool(message.storeFailure);
    }
    if (message.useStatic !== false) {
      writer.uint32(48).bool(message.useStatic);
    }
    if (message.broadcastResults !== false) {
      writer.uint32(56).bool(message.broadcastResults);
    }
    if (message.queueType !== undefined) {
      writer.uint32(64).int32(message.queueType);
    }
    if (message.responseType !== undefined) {
      writer.uint32(72).int32(message.responseType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retryPolicy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.storeSuccess = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storeFailure = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.useStatic = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.broadcastResults = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.queueType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.responseType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WorkerOptions>): WorkerOptions {
    return WorkerOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerOptions>): WorkerOptions {
    const message = createBaseWorkerOptions();
    message.retryPolicy = (object.retryPolicy !== undefined && object.retryPolicy !== null)
      ? RetryPolicy.fromPartial(object.retryPolicy)
      : undefined;
    message.channel = object.channel ?? undefined;
    message.storeSuccess = object.storeSuccess ?? false;
    message.storeFailure = object.storeFailure ?? false;
    message.useStatic = object.useStatic ?? false;
    message.broadcastResults = object.broadcastResults ?? false;
    message.queueType = object.queueType ?? undefined;
    message.responseType = object.responseType ?? undefined;
    return message;
  },
};

function createBaseFunctionCallOptions(): FunctionCallOptions {
  return { timeoutMs: undefined, streaming: undefined, metadata: {} };
}

export const FunctionCallOptions: MessageFns<FunctionCallOptions> = {
  encode(message: FunctionCallOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeoutMs !== undefined) {
      writer.uint32(8).int64(message.timeoutMs);
    }
    if (message.streaming !== undefined) {
      writer.uint32(16).bool(message.streaming);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      FunctionCallOptions_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCallOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeoutMs = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.streaming = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = FunctionCallOptions_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FunctionCallOptions>): FunctionCallOptions {
    return FunctionCallOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCallOptions>): FunctionCallOptions {
    const message = createBaseFunctionCallOptions();
    message.timeoutMs = object.timeoutMs ?? undefined;
    message.streaming = object.streaming ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseFunctionCallOptions_MetadataEntry(): FunctionCallOptions_MetadataEntry {
  return { key: "", value: "" };
}

export const FunctionCallOptions_MetadataEntry: MessageFns<FunctionCallOptions_MetadataEntry> = {
  encode(message: FunctionCallOptions_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCallOptions_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallOptions_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FunctionCallOptions_MetadataEntry>): FunctionCallOptions_MetadataEntry {
    return FunctionCallOptions_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCallOptions_MetadataEntry>): FunctionCallOptions_MetadataEntry {
    const message = createBaseFunctionCallOptions_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFunctionExecutionInfo(): FunctionExecutionInfo {
  return { jobId: "", startedAt: "0", completedAt: undefined, executionTimeMs: undefined, metadata: {} };
}

export const FunctionExecutionInfo: MessageFns<FunctionExecutionInfo> = {
  encode(message: FunctionExecutionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.startedAt !== "0") {
      writer.uint32(16).int64(message.startedAt);
    }
    if (message.completedAt !== undefined) {
      writer.uint32(24).int64(message.completedAt);
    }
    if (message.executionTimeMs !== undefined) {
      writer.uint32(32).int64(message.executionTimeMs);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      FunctionExecutionInfo_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionExecutionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionExecutionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startedAt = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.completedAt = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.executionTimeMs = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = FunctionExecutionInfo_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FunctionExecutionInfo>): FunctionExecutionInfo {
    return FunctionExecutionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionExecutionInfo>): FunctionExecutionInfo {
    const message = createBaseFunctionExecutionInfo();
    message.jobId = object.jobId ?? "";
    message.startedAt = object.startedAt ?? "0";
    message.completedAt = object.completedAt ?? undefined;
    message.executionTimeMs = object.executionTimeMs ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseFunctionExecutionInfo_MetadataEntry(): FunctionExecutionInfo_MetadataEntry {
  return { key: "", value: "" };
}

export const FunctionExecutionInfo_MetadataEntry: MessageFns<FunctionExecutionInfo_MetadataEntry> = {
  encode(message: FunctionExecutionInfo_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionExecutionInfo_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionExecutionInfo_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FunctionExecutionInfo_MetadataEntry>): FunctionExecutionInfo_MetadataEntry {
    return FunctionExecutionInfo_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionExecutionInfo_MetadataEntry>): FunctionExecutionInfo_MetadataEntry {
    const message = createBaseFunctionExecutionInfo_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFunctionResult(): FunctionResult {
  return { output: "", status: undefined, errorMessage: undefined, errorCode: undefined, lastInfo: undefined };
}

export const FunctionResult: MessageFns<FunctionResult> = {
  encode(message: FunctionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.output !== "") {
      writer.uint32(10).string(message.output);
    }
    if (message.status !== undefined) {
      writer.uint32(16).int32(message.status);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.lastInfo !== undefined) {
      FunctionExecutionInfo.encode(message.lastInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastInfo = FunctionExecutionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FunctionResult>): FunctionResult {
    return FunctionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionResult>): FunctionResult {
    const message = createBaseFunctionResult();
    message.output = object.output ?? "";
    message.status = object.status ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.lastInfo = (object.lastInfo !== undefined && object.lastInfo !== null)
      ? FunctionExecutionInfo.fromPartial(object.lastInfo)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
